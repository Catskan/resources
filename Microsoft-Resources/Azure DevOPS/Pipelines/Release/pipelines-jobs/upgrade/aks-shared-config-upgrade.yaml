jobs:
- job: AKS_Shared_Resources_Job
  pool:
    name: $(agent-pool-name)
    demands:
    - agent.os -equals Linux
  
  steps:
  - task: AzureKeyVault@1
    displayName: Shared Azurekeyvault Variables Import
    inputs:
      azureSubscription: '$(azure-subscription)'
      KeyVaultName: '$(shared-keyvault)'
      SecretsFilter: '*'
      runAsPreJob: true

  - task: AzureCLI@2
    displayName: Getting Tenant Keyvault name
    inputs:
      azureSubscription: '$(azure-subscription)'
      scriptType: bash
      scriptLocation: inlineScript
      inlineScript: |
        getvariable=$(az keyvault secret list --vault-name $(vaultsNamesKeyvault) --output table --query [].'name'| grep -w '$(CUSTOMERNAME)KVname')
        kvname=$(az keyvault secret show --name $getvariable --vault-name $(vaultsNamesKeyvault) --query 'value' | tr -d \'\")
        echo "##vso[task.setvariable variable=TENANTKV;]$kvname"
  - task: AzureKeyVault@1
    displayName: Tenant Azurekeyvault Variables Import
    inputs:
      azureSubscription: '$(azure-subscription)'
      KeyVaultName: '$(TENANTKV)'
      SecretsFilter: '*'
      runAsPreJob: false
  
  - task: AzureCLI@2
    displayName: Test AKS resources existence
    inputs:
      azureSubscription: '$(azure-subscription)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az login --identity
        az aks get-credentials --resource-group $(aks-resource-group) --name $(aks-cluster-name) --overwrite-existing --file /home/azureuser/.kube/config
        export KUBECONFIG=/home/azureuser/.kube/config
        kubelogin convert-kubeconfig -l msi
        Namespace=$(kubectl get namespace | grep $(CUSTOMERNAME))
        if [ -z "$Namespace" ]
        then
          "##vso[task.logissue type=error]TENANT NAMESPACE DOESN'T EXIST, PLEASE VERIFY";
          exit 1
        fi
  - task: AzureCLI@2
    displayName: Update Elastic variables
    inputs:
      azureSubscription: '$(azure-subscription)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        if [ -n "$(az keyvault secret show --name elasticSearchUsername --vault-name $(TENANTKV) | jq -r .name)" ]
        then
          elasticsearchUsername=$(az keyvault secret show --name elasticSearchUsername --vault-name $(TENANTKV) | jq -r .value)
          az keyvault secret set --name elasticsearch-username --vault-name $(TENANTKV) --value $elasticsearchUsername
            if [ -n "$(az keyvault secret show --name elasticsearch-username --vault-name $(TENANTKV) | jq -r .name)" ]
            then
              echo "elasticsearch-username sucessfully imported"
              az keyvault secret delete --name elasticSearchUsername --vault-name $(TENANTKV)
            fi
        fi
        if [ -n "$(az keyvault secret show --name elasticSearchPassword --vault-name $(TENANTKV) | jq -r .name)" ]
        then
          elasticsearchPassword=$(az keyvault secret show --name elasticSearchPassword --vault-name $(TENANTKV) | jq -r .value)
          az keyvault secret set --name elasticsearch-password --vault-name $(TENANTKV) --value $elasticsearchPassword
            if [ -n "$(az keyvault secret show --name elasticsearch-password --vault-name $(TENANTKV) | jq -r .name)" ]
            then
              echo "elasticsearch-password sucessfully imported"
              az keyvault secret delete --name elasticSearchPassword --vault-name $(TENANTKV)
            fi
        fi
        if [ -n "$(az keyvault secret show --name elasticSearchDeploymentID --vault-name $(TENANTKV) | jq -r .name)" ]
        then
          elasticsearchDeploymentId=$(az keyvault secret show --name elasticSearchDeploymentID --vault-name $(TENANTKV) | jq -r .value)
          az keyvault secret set --name elasticsearch-deployment-id --vault-name $(TENANTKV) --value $elasticsearchDeploymentId
            if [ -n "$(az keyvault secret show --name elasticsearch-deployment-id --vault-name $(TENANTKV) | jq -r .name)" ]
            then
              echo "elasticsearch-deployment-id sucessfully imported"
              az keyvault secret delete --name elasticSearchDeploymentID --vault-name $(TENANTKV)
            fi
        fi
        if [ -n "$(az keyvault secret show --name elasticSearchEndpointUrl --vault-name $(TENANTKV) | jq .name)" ]
        then
          elasticsearchEndpointUrl=$(az keyvault secret show --name elasticSearchEndpointUrl --vault-name $(TENANTKV) | jq .value)
          az keyvault secret set --name elasticsearch-endpoint-url --vault-name $(TENANTKV) --value $elasticsearchEndpointUrl
            if [ -n "$(az keyvault secret show --name elasticsearch-endpoint-url --vault-name $(TENANTKV) | jq .name)" ]
            then
              echo "elasticsearch-endpoint-url sucessfully imported"
              az keyvault secret delete --name elasticSearchEndpointUrl --vault-name $(TENANTKV)
            fi
        fi
        
  - task: AzureCLI@2
    displayName: Add new Kibana instance url
    inputs:
      azureSubscription: '$(azure-subscription)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        if [ $(az keyvault secret show --name kibana-endpoint-url --vault-name $(TENANTKV) | jq -r .name) ]
        then
          echo "kibana-endpoint-url already exists, doing nothing"
        else
          echo "the secret kibana-endpoint-url doesn't exist, creating it..."
          Deployment=$(curl -s -XGET -H 'Content-Type: application/json' -H "Authorization: Apikey $(elasticSearchApiKey)" "https://api.elastic-cloud.com/api/v1/deployments/$(elasticSearchDeploymentID)")
          kibanaDeploymentUrl=$(jq '.resources.kibana[].info.metadata.aliased_url' <<< ${Deployment})
          az keyvault secret set --name kibana-endpoint-url --vault-name $(TENANTKV) --value $kibanaDeploymentUrl
          if [ $(az keyvault secret show --name kibana-endpoint-url --vault-name $(TENANTKV) | jq -r .name) ]
          then
            echo "kibana-instance-url secret was added successfully"
          else
            echo "Error adding kibana-instance-url variable"
            exit 1
          fi
        fi  

  - task: AzureCLI@2
    displayName: Add Kibana Client Secret to Keyvault
    inputs:
      azureSubscription: '$(azure-subscription)'
      scriptType: 'bash'
      scriptLocation: 'inlineScript'
      inlineScript: |
        if [ -n "$(az keyvault secret show --name kibana-client-secret --vault-name $(TENANTKV) | jq -r .name)" ]
        then
          echo "Kibana Client Secret already exists, skipping."
        else
          randomPass="$(cat /dev/urandom | tr -c -d 'A-Za-z0-9' | head -c 23)"
          az keyvault secret set --name kibana-client-secret --vault-name $(TENANTKV) --value $randomPass
          echo "kibana-client-secret created successfully."
        fi

  - task: AzureKeyVault@1
    displayName: Tenant Azurekeyvault Variables Import Updated
    inputs:
      azureSubscription: '$(azure-subscription)'
      KeyVaultName: '$(TENANTKV)'
      SecretsFilter: '*'
      runAsPreJob: false

  - task: replacetokens@5
    displayName: Replace variables in kubernetes templates
    inputs:
      rootDirectory: '$(System.DefaultWorkingDirectory)/deployment/pipelines-files/kubernetes-files/vantagedx'
      targetFiles: |
        ingress-cluster1.yaml
        configmap-cluster1.yaml
        secret-cluster1.yaml
      encoding: 'auto'
      writeBOM: true
      actionOnMissing: 'fail'
      keepToken: false
      tokenPrefix: '#{'
      tokenSuffix: '}#'
  
  - task: Kubernetes@1
    displayName: Apply VantageDx shared configmap
    inputs:
      connectionType: 'None'
      forceUpdateConfigMap: true
      namespace: '$(CUSTOMERNAME)'
      command: apply
      arguments: -f $(System.DefaultWorkingDirectory)/deployment/pipelines-files/kubernetes-files/vantagedx/configmap-cluster1.yaml
      secretType: 'generic'
  
  - task: Kubernetes@1
    displayName: Apply VantageDx shared secret
    inputs:
      connectionType: 'None'
      forceUpdate: true
      namespace: '$(CUSTOMERNAME)'
      command: apply
      arguments: -f $(System.DefaultWorkingDirectory)/deployment/pipelines-files/kubernetes-files/vantagedx/secret-cluster1.yaml
      secretType: 'generic'

  - task: Kubernetes@1
    displayName: Apply shared Ingress config
    inputs:
      connectionType: 'None'
      forceUpdate: true
      namespace: '$(CUSTOMERNAME)'
      command: apply
      arguments: -f $(System.DefaultWorkingDirectory)/deployment/pipelines-files/kubernetes-files/vantagedx/ingress-cluster1.yaml
      secretType: 'generic'